#+TITLE: Informatics basics
#+AUTHOR: Starovoytov Alexandr, Grechko Georgy
#+SETUPFILE: retro_dark.theme

[[https://github.com/stewkk/iu9-scheme/][Лабы и дз]]

* Преподаватель
  - Коновалов Александр Владимирович
  - 89175404352
  - akonovalov@bmstu.ru
  - a.v.konovalov87@mail.ru
* Основные понятия информатики
** Данные
это представление фактов, понятий, инструкций в форме, приемлемой
для обмена, интерпретации или обработки человеком или с помощью
автоматических средств
** Алгоритм
это конечная совокупность точно заданных правил решения прозвольного класса
задач или набор инструкций, описывающий порядок действий исполнителя для
решения некотрой задачи
** Свойства алгоритма:
1. Дискретность \\
    делится на отдельные элементарные части,
    отвечающие за определенные действия.
2. Детерминированность \\
    на одних и тех же входных данных - один и тот же результат.
3. Понятность \\
    элементы алгоритма должны быть понятны исполнителю.
4. Завершаемость \\
    если не завершается - то это вычислительный процесс.
5. Массовость \\
    алгоритм пригоден для решения всех задач данного типа.
6. Результативность \\
    указывает на наличие таких исходных данных, для которых реализуемый
    по заданному алгоритму вычислительный процесс должен через конечное
    число шагов остановиться и выдать искомый результат.
** Компьютерная программа
это алгоритм, записанный на некотором языке программирования
** Язык программирования
формальный язык, предназначенный для записи компьютерных программ
** Компьютер
программно управляемое устройство для обработки информации
** Подпрограмма
некоторый именованный блок кода. \\
Вызывающая программа приостанавливается, управление передается
подпрограмме,
по завершению управление передается обратно
** Сопрограмма
в отличие от подпрограммы работает поочередно с вызывающей программой.
При повторном вызове возобновит выполнение с момента, где остановилась
* Парадигмы программирования
совокупность идей и понятий, определяющих стиль написания компьютерных
программ (подход к программированию). Это способ концептуализации,
определяющий организацию вычислений и структурирование работы, выполняемой
компьютером.
** Основные группы парадигм
1. Императивные \\
   способ записи программ, в котором указывается последовательность
   действий \\
   основной признак - оператор присваивания (меняющий значение переменной)
   1. Структурное программирование \\
      программа является композицией блоков с одним входом и
      одним выходом \\
      (есть операторы ветвления и цикла, но нет goto)
   2. Процедурное программирование \\
      совокупность подпрограмм, где одни подпрограммы вызывают другие
   3. Объектно-ориентированное \\
      программа рассматривается как набор некоторых взаимодействующих
      объектов. \\
      Объект сочетает в себе данные и методы их обработки,
      методы вызываются в ответ на сообщение: \\
      посылаем сообщение объекту -> вызывает метод -> возвращает ответ \\
      объекты объединяются в классы
2. Декларативные \\
   способ записи программ, в котором описывается взаимосвязь между
   данными, описывается цель, но не последовательность шагов ее вычисления
   1. Функциональное \\
      алгоритм записывается как набор взаимосвязанных функций, функции
      рассматриваются с математической точки зрения, \\
      описывает взаимосвязь между данными и результатом
      #+begin_src "c"
      x = f(y) + g(z);
      #+end_src
   2. Логическое (Prolog + отчасти SQL) \\
      алгоритм описывает взаимосвязь между понятиями. \\
      Выполнение программы сводится к выполнению запросов
3. Метапрограммирование \\
   метаирония. Программа рассматривается как данные/объект для
   другой программы
   1. Программу пишут программы \\
      Например: макросы, генераторы кода, шаблоны С++ (фигня нечитаемая
      зачем он постоянно в руках часы крутит попит симпл димпл круче
      нет попит симпл димпл попит симпл димпл маленький красивый
      попит большой и милый)
   2. Программа взаимодействует с вычислительной средой \\
      Рефлексия или интроспекция - самоанализ. \\
      Например, посмотреть поля и значения в объекте класса
** примеры
#+begin_example
ИП: sort(array);
ФП: sorted_list = sort(list)
    sorted_list - константа, т.к. нет присваивания
ЛП: sort(unsorted, sorted)
#+end_example
* Язык Scheme
** информация о языке
Lisp 1950-е годы Джон МакКарти \\
LISt Processing \\
Scheme 1970-е годы Абельсон и Сассман \\
изучаем R5RS \\
современная редакция R7RS
- другие языки семейства LISP:
    - Common Lisp
    - Clojure
    - Racket
** основные постулаты языка LISP
1. единство кода и данных
2. все есть список
3. выражение является списком \\
   операция указывается в первом элементе
4. все выражения вычисляют значения (почти все)
** операторы
#+begin_src scheme :session :results value :exports both
;; <терм> ::= <атом>|<список>
;; <атом> ::= <перем>|<число>|<симол>|<строка>
;; <список> ::= (<термы>)
;; <термы> ::= <пусто> | <терм><термы>
;; <пусто> ::=
;; i-am-variable - имя переменной может включать "-", "+", "*", "/"...
(+ 1 2 3) ;; список
;; "+" - имя функции сложения
;; "1 2 3" - аргументы
;; элементы списка разделяются пробелами

#+end_src

#+RESULTS:
: 6

#+begin_src scheme :session :exports both
((a 1)(b 2)(c 3)) ;; список списков

;; по умолчанию выражение вида
;; (f a b c) - вызов функции
;; ((f x) y) - сначала вызывается (f x),
;; то, что она вычислит с аргументом y
;; Особая форма - первый элемент списка - ключевое слово

(define pi 3.1415926)
;; pi - имя переменной
;; 3.14.. - значение

(define pi (* 4 (atan 1)))

(define (f a b c) ;; опеределяет функции
    (+ (* 2 a) (/ b c)))

;; (if <выраж 1>
;;     <выраж 2>
;;     <выраж 3>)

;; Если <выраж 1> - ложь,
;; значением (if ...) станет значение <выраж3>
;; (<выраж 2> не вычисляется), и наоборот

;; #f - ложь
;; #t - истина
;; if считает истиной все что не ложь
#+end_src


#+begin_src scheme :session :exports both
(if 1 2 3)
#+end_src

#+RESULTS:
: 2

#+begin_src scheme :session :exports both
(if #f (/ 1 0) (/ 10 5))

#+end_src

#+RESULTS:
: 2

#+begin_src scheme :exports both
(if #t (/ 1 0) (/ 10 5))
#+end_src

#+RESULTS:
: Throw to key `numerical-overflow' with args `("/" "Numerical overflow" #f #f)'.

#+begin_src scheme
;; (< x y)
;; (> x y)
;; (= x y)
;; >=
;; <=
;; (/ x y)
(/ 10 3)
#+end_src

#+RESULTS:
: 10/3

#+begin_src scheme :session :exports both
;; (quotient x y) - целое деление
(quotient 30 7)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme :session :exports both
;; (remainder x y) -> остаток
(remainder 30 7)
#+end_src

#+RESULTS:
: 2

#+begin_src scheme :session :exports both
;; "особые формы"
;; (and e1 e2 ... en) - возвращает #f если хотя бы один ei = #f, иначе en
;; (or ...) - вернет первое не ложное значение


(and 1 2 #f (/ 1 0))
#+end_src

#+RESULTS:
: #f
#+begin_src scheme :session :exports both
;; (or (= x 0) (/ 1 x)) - не приведет к ошибке деления на 0, никогда
#+end_src

#+begin_src scheme :session :exports both
(or (= 1 0) (/ 1 0))
#+end_src

#+RESULTS:

#+begin_src scheme :session :exports both
;; (not x) - логическое отрицание #f -> #t
;; not x -> #f, x != #f
;; вычисления ленивые!
#+end_src

#+begin_src scheme :exports both
(+ 1 2 3)
#+end_src

#+RESULTS:
: 6

#+begin_src scheme :session :exports both
(define pi (* 4 (atan 1)))
#+end_src
#+begin_src scheme :session :exports both
(define (area r) (* r r))
#+end_src
#+begin_src scheme :session :exports both
(define e (exp 1))
#+end_src
#+begin_src scheme :session :exports both
(define (hypot x y) (sqrt (+ (* x x) (* y y))))
; if всегда в 3 строки
#+end_src
#+begin_src scheme :session :exports both
(define (fac x) (if (= x 0)
                     1 (* (fac (- x 1)) x)))
#+end_src
#+begin_src scheme :session :exports both
(define (my-positive? n) (> n 0))
#+end_src
#+begin_src scheme :session :exports both
(define (my-abs x)
  (if (< x 0)
      (-x)
      x))

#+end_src
#+begin_src scheme :session :exports both
(define (factorial n)
  (define loop acc i)
  (if (> i n)
      acc
      (loop (* acc i) (+ i 1)))
  (loop 1 1))
#+end_src
#+begin_src scheme :session
(define (my-odd n)
  (= 0 (remainder n 2)))
#+end_src

#+RESULTS:
: #<unspecified>

#+begin_src scheme :session
(define (my-even n)
  (= 1 (remainder n 2)))
#+end_src

#+RESULTS:
: #<unspecified>

#+begin_src scheme :session :exports both
(my-odd 1)
#+end_src

#+RESULTS:
: #f

#+begin_src scheme :session :exports both
(my-odd 2)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(my-even 1)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(my-even 2)
#+end_src

#+RESULTS:
: #f

* Лекция 2
** Codestyle in if-statements
1. Условное выражение лучше писать в 3 строки: \\
   условие \\
   ветка 1 \\
   ветка 2
2. Плохой стиль - использовать в ветках #t и #f
   #+begin_src scheme
;; неверно
(if e1
    e2
    #t)
;; верно
(or (not e1) e2)

;; неверно
(if e1
    #t
    e2)
;; верно
(or e1 e2)

;; неверно
(if e1
    e2
    #f)
;; верно
(and e1 e2)

;; неверно
(if e1
    #f
    e2)
;; верно
(and (not e1) e2)
   #+end_src
** Выражение cond
#+begin_src scheme
(cond (c1 e1)
      (c2 e2)
      ...
      (cn en)
      (else eE)) ;; можно без else
;; для первого же условия ci не являющ #f выполняет ei, иначе eE
;; допустимо писать #f #t
#+end_src
** Выражение case
не будет на экзамене,
*** TODO добавить самостоятельно
** Простые (не составные) значения
+ Числа: 5, 100500, 6.12324, -1 1/3...
+ строки: "Hello", можно использовать esape-последовательности языка C
+ Логический тип: #t #f
+ Литерный (character): #\x, #\newline
+ Символьный (symbol): 'hello
+ Процедурный (lambda (...))
+ ...
** Функции высших порядков
#+begin_src scheme
;; Конструкция (lambda ...) строит процедуру
;; принятно "процедура", а не "функция"
(lambda (<параметры>)
  <выражение>)
;; В результате получается значение, которое можно вызвать
;; Например:
((lambda (x y)
   (+ x y))
 5 3) ;; -> 8
(lambda (x y) ;; ->
  (+ x y)) ;;    -> СТРОИТ ПРОЦЕДУРУ
;; эта процедура вызывается с 2-мя параметрами: 5 3

((lambda (f) (f (f 2))) ;; принимает функцию вызывает ее с 2, вызывает ее от результата первого вызова
 (lambda (x) (* x x))) ;; -> 16
;; (2^2)^2 = 16

((lambda (f) (f (f 81))) sqrt) ;; -> 3

((lambda (f) (f (f 81)))
 lambda (y) (sqrt y)) ;; -> 3

;; (lambda (x) (g x)) тожд. g - хватает для описания любого алгоритма

;; (lambda (x y) (n x y)) тожд. n
;; n - конверсия буква "эта"

(define pi (* 4 (atan 1)))

(define square
  (lambda (x) (* x x)))
;; то же, что и:
(define (square x) ;; -> Сокращенная запись
  (* x x))         ;; -> (синтаксический сахар)

;; компилируется в один и тот же код

(define (f ...) ...)
;;   ||
(define f (lambda (...) ...))

(define (multi-apply f x n)
  (if (= n 0)
      x
      (f (multi-apply f x (- n 1)))))
f'(x) = x
f'(x) = f(f(f...f(x)...))
;;      n раз
(define (square x)
  (* x x))
(multi-apply square 3 3) ;; -> 6561 = 3^8
(multi-apply square 2 4) ;; -> 65536 = 2^16
(multi-apply
 (lambda (z) (+ 1 z))
 0 7) ;; -> 7

(define (select n)
  (cond((= n 0) +)
       ((= n 1) -)
       ((= n 2) (lambda (x y)
                  (sqrt (+ (* x x) (* y y)))))
       (else (lambda (x y) 0))))

((select 0) 2 3) ;; -> 5
((select 1) 10 7) ;; -> 3
((select 2) 3 4) ;; -> 5
((select 10) 100 500) ;; -> 0
#+end_src
* Лекция 3
+ 1 порядок - простое возвр значение (не функция)
+ высшего порядка - возвращает функцию
+ в Scheme - функции - объекты 1го класса
+ объекты первого класса - с которыми можно применять все допустимые операции (не пораженные в правах)
 #+begin_src scheme
(cond (усл1 выр1)
      (услk -> проц)
      ...
      (else выражE))

;; пример:
(define (f a b c)
  (cond (a -> (lambda (x) -> (* x x)))
        (b -> sqrt) ;; ((assoc xsk) -> car)
        (c -> -)
        (else 0)))
(f #f 9 5) ;; -> 3
(f 15 3 #f) ;; -> 225
(f #f #f 100) ;; -> -100
(f #f #f #f) ;; -> 0


(define mul
  (lambda (x)
    (lambda (y) (* x y))))

((mul 7) 9) ;; -> 63
((mul 3) 3) ;; -> 9
(define twice (mul 2)) ;; дважды
(define triple (mul 3)) ;; трижды
(twice 7) ;; -> 14
(triple 12) ;; -> 36

(define (pair x y)
  (lambda (f) (f x y)))

(define (first p)
  (p (lambda (x y) x)))

(define (second p)
  (p (lambda (x y) y)))

(define p1 (pair 2 3))
;; p1 ~ (lambda (f) (f 2 3))
(first p1) -> (first (lambda (f) (f 2 3))) ->
-> ((lambda (f) (f 2 3))
    (lambda (x y) x)) ->
-> ((lambda (x y) x) 2 3) -> 2
(first p1) ;; -> 2
(second p1) ;; -> 3

(define (swap p)
  (p (lambda (x y) (pair y x))))
(define (swap p)
  (pair (second p) (first p)))
 #+end_src
** let, let* и letrec
Используются для определения вспомогательных переменных
#+begin_src scheme
(let ((перем1 знач1)
      (перем2 знач2)
      ...
      (перемn значn))
  выраж)
;; переменные могут использоваться только в выражении "выраж"

;; вычисление площади треугольника по формуле герона:
(let (s a b c)
  (let ((p (/ (+ a b c) 2)))
    (sqrt (* p (- p a) (- p b) (- p c)))))
;; Значение "вспомогательной" переменной не может
;; ссылаться на предыдущие
(let ((v1 e1) .. (vN eN)) e)
;;       |||
((lambda (v1 .... vN) e)
 e1 ....... eN)
;; порядок вычисления аргументов не определен
;;;;;;;;;;;;;;;;;;;;
;; let*
(let* ((перем1 знач1)
       (перем2 знач2)
       ...
       (перемn значn))
  выраж)
;; В выражении значk можно использовать перемi, i < k
(let* ((a 7)
       (b (+ a 5))
       (c (* a b))
       (d (- a c)))
  (+ a b c d))
;; значения вычисляются строго сверху-вниз
(let* ((v1 e1) ... (vN eN)) e)
;;          |||
(let ((v1 e1))
  (let ((v2 e2))
    (let ((v3 e3)))
    .........
 e))


            ;;;;;;;;;;;;;;;;;;
(letrec ((перем знач)
         (перем знач)
         ....
         (перемn значn))
  выраж)
;; в выражении значk можно использовать любые переменные

(define (fact n)
  (letrec ((loop
            (lambda (i res)
              (if (> i n)
                  res
                  (loop (+ 1 i) (* i res))))))

  (loop 1 1)))
;; let с рекурсией
;; аналогичен обычному let, но в перем0 кладется рекурсивная процедура
(let перем0 ((перем1 знач1)
             (перем2 знач2)
             ......
             (перемn значn))
     выраж)
;; рекурсивная функция - с n параметрами
(define ((перем0 перем1 .. перемn)
         выраж)
  (перем0 знач1 ... значn))
(define (fact n)
  (let loop((i 1) (res 1))
    (if (> i n)
        res
        (loop (+ i 1) (* res i)))))

(define (loop i res)
  ......)
(loop 1 1)
#+end_src

* Лекция 4
** хвостовая рекурсия
может неявно компилироваться в цикл
*** рекурсия
случай, когда задачу можно разбить на одну или несколько меньших задач, подобных исходной
*** как цикл while выражать в виде рекурсии
цикл - выполнение n-ого количества одинаковых операций \\
сводится к: выполнение одного шага + выполнение остальных \\
если алгоритм подразумевает цикл с изменяющимися значениями переменных, то
1. определяем вспомогательную функцию
   ее параметры - изменяющиеся переменные
2. функция имеет вид
   #+begin_src scheme
(define (loop ...)
  (if (продолжать цикл?)
      (loop <новые значения параметров>)
      (выход из цикла-формирование полезного значения)))
   #+end_src
3. вызываем функцию \\
   в качестве параметров - начальные значения переменных
**** примеры:
#+begin_src python
def gcd(x, y):
    while y != 0:
        x, y = y, x % y
    return x
#+end_src
#+begin_src scheme
(define (my-gcd x y)
  (if (not (= y 0))
      (my-gcd y (remainder x y))
      x))
#+end_src
#+begin_src python
def fact(n):
    i = 1
    res = 1
    while i <= n:
        res = res * i
        i = i + 1
    return res
#+end_src
#+begin_src scheme
(define (fact n)
  (define (loop i res)
  (if (<= i n)
      (loop (+ i 1) (* res i))
      res))
  (loop 1 1))

(define (fact n)
  (let loop ((i 1)
             (res 1))
    (if (<= i n)
        (loop (+ i 1)
              (* res i))
        res)))
#+end_src
*** определение хвостовой рекурсии
рекурсивный вызов называется хвостовым, если он выполняется последним
+ 2 вида передачи управления: вызов подпрограммы и goto
+ стек FILO
*** вызов подпрограммы
1. сохраняем контекст
2. передаем управление на подпрограмму
3. подпрограмма завершается
4. восстанавливаем контекст вычислений
Контекст вычислений содержит значения локальных переменных и адрес возврата -
место в коде, с которого надо восстановить работу при завершении вызова подпрограммы. \\
Контексты вычислений образуют стек вызовов (для вложенных подпрограмм)
*** TODO fix name
в общем случае вызов функции в Scheme работает как вызов подпрограммы
#+begin_src scheme
(define (gcd x y)
  (if (= y 0)
      x
      (gcd y (remainder x y))))
#+end_src
**** хвостовая рекурсия
для хвостовых вызовов контекст вычисления можно не сохранять, т.к. он уже не нужен:
- вызов последний, других вызовов после него нет, локальные переменные можно забыть
- в точке возврата будет выполняться возврат из вызывающей функции
- стек расти не будет, т.к. контексты вызовов(стековые фреймы) создаваться не будут
**** нехвостовая рекурсия
стек вызовов будет расти \\

Умный компилятор может распозновать хвостовую рекурсию и компилировать ее в цикл
**** пример нехвостовой рекурсии
#+begin_src scheme
(define (fact n)
  (if (<= n 1)
      1
      (* n (fact (- n 1))))) ;; после рекурсивного вызова вызывается * (умножение)
;; значит, вызов не последний
;; после рекурсивного вызова используется локальная переменная
;; достаточно одно из этих двух условий
#+end_src

**** TODO написать с goto; пример хвостовой рекурсии
#+begin_src C
int fact(int n) {
    return loop(n, 1, 1);
}
int loop(int n, int i, int res) {
    if (i <= n) {
        return loop(n, i + 1, res * i);
    } else {
        return res;
    }
}
int loop(int n, int i, int res) {
    LOOP:
    if (i <= n) {
        res = res * i;
        i = i + 1;
        goto LOOP;
    } else {
        return res;
    }
}
#+end_src
**** символы
Если поставим одинарную кавычку перед именем переменной(или ключевым словом), получим символ:
#+begin_src scheme
'x        'hello
'lambda   'factorial
#+end_src
Это атом, представляет зацитированное(цитата) "замороженное" имя \\

Цитирование строк, чисел, литер их не измненяет
#+begin_example
'1 -> 1
'"hello" -> "hello"
'#\a -> #\a
'#\newline -> #\newline
'#t -> #t
'#f -> #f
#+end_example
*** списки
Список - последовательность значений,
основная структура данных в языках семейства LISP \\
Во время выполнения выглядит примерно так:
#+begin_src scheme
(1 2 3 4)
#+end_src
Создание списка:
#+begin_src scheme
(list <элементы>)
(list 1 2 3 4) -> (1 2 3 4)
(list) -> () - пустой список
#+end_src
Операции над списками:
1. cons

   #+begin_src scheme
   (cons <голова> <хвост>) -> <список>
   <голова> - некоторое значение
   <хвост> - список
   #+end_src
   Строит список, где первый элемент голова, а все остальные хвост
   #+begin_src scheme :results raw :exports both
(define odds (list 3 5 7))
(cons 2 odds)
   #+end_src

   #+RESULTS:
   (2 3 5 7)

   #+begin_src scheme
(cons 1 (cons 9 odds)) -> (1 9 3 5 7)
(cons 'x (list)) -> (x)
   #+end_src
#+begin_src scheme
(list? <значение>) -> ;; #t | #f
(list? odds) -> #t
(list? 7) -> #f
;; это предикат типа
(null? <список>) -> <лог значение>
#t - пустой
#f - непустой
(null? odd) -> #f
(null? (list)) -> #t
(car <список>) -> <голова> ;; content of address register
(cdr <список>) -> <хвост> ;; content of destination register
cdr - все кроме головы
(car odds) -> 3
(cdr odds) -> (5 7)
(car (cdr odds)) -> 5
(cdr (cdr odds)) -> 7
(cdr (cdr (cdr odds))) -> ()
(cadr ....) == (car (cdr ..))
(caar ...) == (car (car ...))
(cdadr ....) == (cdr (car (cdr ....)))
выполняется справа налево
#+end_src
#+begin_src scheme
(define nested (list (list 1 2)
                     (list 3 4)))
nested -> ((1 2) (3 4))
(cdar nested) == (cdr (car nested)) -> (2)
(car nested) -> (1 2)
(cdr nested) -> ((3 4))
(cadr nested) -> (3 4)
(caadr nested) -> 3
(cdadr nested) -> (4)

#+end_src
***** списки можно цитировать
#+begin_src scheme
'(1 2 3 4) -> (1 2 3 4)
'(a b c d) -> (a b c d)
(list 'a 'b 'c 'd) -> (a b c d)
#+end_src

* Лекция 5
#+begin_src scheme
() - пустой список
Функция (length <список>) -> <число> ;; O(n)
(length '(1 2 3)) -> 3
(length '((1 2) (3 4))) -> 2
(length '()) -> 0

(append <список> <список> ...) -> <список>
#+end_src
#+begin_src scheme
(append '(1 2) '(3 4 5) '(6 7)) -> (1 2 3 4 5 6 7)
(append '(a b c) '(d e)) -> (a b c d e)
(+ 2 3) -> 5
(+ 2) -> 2
(+) -> 0
(* 2 3) -> 6
(* 2) -> 2
(*) -> 1
(append '(1 2 3)) -> (1 2 3)
(append) -> ()
(define (my-length xs) ;; xs - "иксы"; ys - "игреки"
  (if (null? xs)
      0
      (+ (my-length (cdr xs)) 1)))
;; вариант с хвостовой рекурсией
(define (my-length xs)
  (define (loop n xs)
    (if (null? xs)
        n
        (loop (+ 1 n) (cdr xs))))
  (loop 0 xs))

(define (sum xs)
  (if (null? xs)
      0
      (+ (car xs)
         (sum (cdr xs)))))
(define (my-append xs ys)
  (if (null? xs)
      ys
      (cons (car xs)
            (my-append (cdr xs) ys))))

(my-append '(a b c) '(x y z))
(cons (car '(a b c))
      (my-append (cdr '(a b c)) '(x y z)))
(cons 'a (my-append '(b c) '(x y z)))
(cons 'a (cons 'b (cons 'c (my-append '() '(x y z)))))
(cons 'a (cons 'b (cons 'c '(x y z))))
'(a b c x y z)
#+end_src
** функция map
#+begin_src scheme
(map f (x1 x2 ... xn)) -> ((f x1) (f x2) .. (f xn))
(map - '(1 2 4)) -> (-1 -2 -4)
(map car '((a b) (c d) (e f))) -> (a c e)
(map cdr '((a b) (c d) (e f))) -> ((b) (d) (f))
(map even? '(2 3 5 7 11)) -> (#t #f #f #f #f)
(define (my-map f xs)
  (if (null? xs)
      '()
      (cons (f (car xs))
            (my-map f (cdr xs)))))

(map f (x1 ... xk) (y1 ... yn) (z1 .... zm))
-> ((f x1 y1 z1) (f x2 y2 z2) ... (f xl yl zl)) ;; l = min(k, n, m)
(map + '(1 3 5) '(4 2 2 8)) -> (5 5 7)
#+end_src
Напишем функцию (cart-prod xs ys)
вычисляющую декартово произведение
#+begin_src scheme
(cart-prod '(a b c) '(1 2 3 4)) -> ((a 1) (a 2) (a 3) (a 4) (b 1) (b 2) (b 3) (b 4) (c 1) (c 2) (c 3) (c 4))
(define (cart-prod xs ys)
  (if (null? xs)
      '()
      (append (map (lambda (y) (list (car xs) y))
                   ys)
              (cart-prod (cdr xs) ys))))
#+end_src
** списков не существует (в Scheme)
А существуют cons-ячейки - пары(кортежи) из двух значений \\
Функция cons порождает cons-ячейку, car и cdr - доступ к её элементам \\
#+begin_src scheme
(cons 1 7) -> (1.7)
#+end_src
Константа '() - пустой список - это атом \\
Список (правильный список) - это:
1. пустой список '()
2. cons-ячейка, cdr которой - правильный список
#+begin_src scheme
'(1 2 3 4) == (cons 1 (cons 2 (cons 3 (cons 4))))

'((a b) (c d e) (f g))

'(())
(list (list)) == '(())
(car '(())) -> '()
(cdr '(())) -> '()
'(1)
;; Неправильный список:
(cons 1 (cons 2 (cons 3 4))) -> (1 2 3.4)
;; точка отделяет car от cdr( голову от хвоста )
'(1.2)
(car '(1.2)) -> 1
(cdr '(1.2)) -> 2
'(1 . '()) -> (1)
'(1 2 .(3 4)) -> (1 2 3 4)
'(1 2 3 4 . '()) -> (1 2 3 4)
'(().()) -> (())
'(1.(2.(3.(4.())))) -> (1 2 3 4) ;; используется точечная нотация
#+end_src
** Функции с переменным числом параметров
#+begin_src scheme
(lambda xs ...)
     ;; |-> без скобок
;; все параметры упадут в xs
(lambda (a b c.xs) ...)
;; принимает минимум 3 параметра
(define (f a b c.xs)
  .......)
;; функция с как минимум 3мя параметрами
;; все дополнительные упадут в список xs
(define (f . xs)
  ...)
;; ==
(define f
  (lambda xs ...))
;; функция с произвольным числом параметров
(define (n . xs)
  (length xs))
(n 1 7 8) -> 3
(n 1 1 1 1) -> 4
(n) -> 0
(define (my-list . xs) xs)
(my-list 1 2 3) -> (1 2 3)
((lambda xs xs)) -> ()
((lambda xs xs) 1 2 3) -> (1 2 3)
(define my-list (lambda xs xs))
#+end_src

* Лекция 6
#+begin_src scheme
(apply func xs)
#+end_src
Вызывает функцию с переменным числом параметров, \\
передавая xs в качестве всех аргументов
#+begin_src scheme
(apply + '(1 2 3 4))
(+ 1 2 3 4) ;; -> 10
(apply + numbers) ;; numbers - список чисел
#+end_src

** Вычислительная сложность
Это оценка времени работы алгоритма
с точностью до сомножителя \\
Записывается как O(f(n)), \\
где f(n) - некоторая функция, зависящая от входных данных (или объема входных данных) \\
O(n^3) - время работы пропорционально кубу n \\
O(|xs|) - линейно от длины списка xs \\
O(1) - константное время, не зависит от входных данных \\
#+begin_src scheme
(length xs) ;; O(|xs|)
(null? xs), (cons x xs), car, cdr ;; O(1)
#+end_src
#+begin_src scheme
(pair? a) ;; -> #t, если a - cons-ячейка
          ;; -> #f в остальных случаях
(pair? 1) ;; -> #f
(pair? '(1 2 3)) ;; -> #t
(pair? '()) ;; -> #f

(list? '()) ;; -> #t

(pair? a) ;; O(1)
(list? a) ;; O(|a|)
#+end_src
*** TODO вынести комментарии из кода
#+begin_src scheme
(define (sum xs)
     (if (> (length xs) 0)
         (+ (car xs) (sum (cdr xs)))
         0))
;; car, cdr, рекурсивный вызов, >, if, + -> O(n)
;; (length xs) -> O(|xs|)
;; Время работы без учета рекурсивного вызова - O(|xs|)
;; Число рекурсивных вызовов - O(|xs|)
;; В сумме |xs| * O(|xs|) = O(|xs|^2)
;; Т.е. сложность квадратичная
;; оценим точнее: O(n + (n - 1) + ... + 3 + 2 + 1) = O((n * (n + 1))/2) = O((n^2) / 2 + (n^2) / 2) = O(n^2)
#+end_src

#+begin_src scheme
(define (sum xs)
     (if (not (null? xs))
         (+ (car xs) (sum (cdr xs)))
         0))
;; На каждом вызове все операции, кроме рекурсивного вызова - O(1)
;; значит общая сложность |xs| * O(1) = O(|xs|)
#+end_src
*** Сравнение на равенство
#+begin_src scheme
(= x y) ;; работает только с числом
;; функции, работающие со всем:
(equal? x y) ;; сравнивает по значению
(eqv? x y), (eq? x y) ;; сравнивают по ссылке, разницу смотреть в документации
;; рекомендуется всегда использовать (equal?), результат наиболее предсказуем
#+end_src
#+begin_src scheme :exports both
(= 3 3.0)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :exports both
(equal? 3 3.0)
#+end_src

#+RESULTS:
: #f

#+begin_src scheme :exports both
(eq? (list 1 2 3) (list 1 2 3))
#+end_src

#+RESULTS:
: #f

#+begin_src scheme :exports both
(equal? (list 1 2 3) (list 1 2 3))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(define xs (list 1 2 3))
(eq? xs xs)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(equal? xs xs)
#+end_src

#+RESULTS:
: #t

*** дз сдвигается на неделю (28.09 сдаем только первые 2 задачи)
множества пишем за O(n^2), имитируя с помощью списков

*** как достигать линейной сложности
если хотим построить список в определенном порядке, иногда имеет смысл сделать список в обратном порядке, а потом реверсировать
#+begin_src scheme
(reverse xs) ;; - реверсирует список за O(|xs|)
(reverse '(a b c)) ;; -> (c b a)
#+end_src
cons/reverse - Scheme \\
push/reverse - Common Lisp \\
Это прием построения списков с хвостовой рекурсией
#+begin_src scheme
(define (add-ones xs)
  (if (null? xs)
      '()
      (cons (+ 1 (car xs))
            (add-ones (cdr xs)))))
(add-ones '(1 2 3)) ;; -> (2 3 4), O(|xs|) - рекурсивная

;; вариант с хвостовой рекурсией
(define (add-ones xs)
  (define (loop res xs)
    (if (null? xs)
        res
        (loop (append res (list (+ 1 (car xs))))
              (cdr xs))))
  (loop '() xs))
;; её сложность - O(|xs|^2)
;; т.к. сложность append O(|res|)

(define (add-ones xs)
  (define (loop res xs) ;; res строится в обратном порядке
    (if (null? xs)
        (reverse res)
        (loop (cons (+ 1 (car xs)) res)
              (cdr xs))))
  (loop '() xs))
;; имеет линейную сложнсть O(|xs|)
#+end_src

* Лекция 7
* Лекция 8
** Сведения ко второй части домашнего задания
  :PROPERTIES:
  :CUSTOM_ID: сведения-ко-второй-части-домашнего-задания
  :END:
*** Тип данных =vector=
   :PROPERTIES:
   :CUSTOM_ID: тип-данных-vector
   :END:
Списки --- основные структуры данных в языках семейства Lisp. В Scheme
они не примитивный тип, а надстройка над cons-ячейками.

Списки по своей сути однонаправленны --- можем их читать слева-направо
при помощи =car= и =cdr= и наращивать справа-налево при помощи =cons=.

Недостаток списков --- это производительность при доступе по номеру.

Есть встроенная функция =(list-ref xs n)=, возвращающая n-й элемент:

#+begin_src scheme
  (define xs '(a b c d))
  (list-ref xs 2)          →  c
#+end_src

(элементы нумеруются с нуля)

Но сложность той же =list-ref= --- =O(n)=, где =n= --- номер элемента.

Для преодоления этого недостатка в Scheme есть встроенный тип данных
=vector=, допускающий произвольный доступ к элементам для чтения
и записи за константное время.

Нужно помнить, что =vector= --- ссылочный тип, в том смысле, что если мы
в две переменные положим один и тот же вектор, то изменения вектора
через одну переменную будут видны через другую.

#+begin_src scheme
  (define v #(1 2 3 4))
  (define w v)

  (vector-set! v 2 77)
  w                                  → #(1 2 77 4)
#+end_src

Создаётся вектор при помощи литерала =#(…)=, при этом его содержимое
неявно цитируется, также как и при ='(…)=.

#+begin_src scheme
  (define a 100)
  (define v #(1 2 3 a 4 5 6))
  a                                  → #(1 2 3 a 4 5 6)
#+end_src

Т.е. =a= внутри вектора будет не переменной, а процитированным символом.

Функция =make-vector= создаёт новый вектор:

#+begin_src scheme
  (make-vector size)
  (make-vector size init)
#+end_src

где =size= --- размер вектора, а =init= начальное значение элементов.
Т.к. вектора используются чаще для расчётов, инициализация
по умолчанию --- =0=.

#+begin_src scheme
  (make-vector 10)                   → #(0 0 0 0 0 0 0 0 0 0)
  (make-vector 10 'a)                → #(a a a a a a a a a a)
#+end_src

Предикат типа --- =vector?=.

#+begin_src scheme
  (vector? #(1 2 3))                 → #t
  (vector? '(1 2 3))                 → #f
#+end_src

Обращения к элементам вектора:

#+begin_src scheme
  (vector-ref v n)                   → n-й элемент вектора (начиная с 0)
  (vector-set! v n x)                ; присваивает n-му элементу
                                     ; новое значение x

  (define v (make-vector 5))
  v                                  → #(0 0 0 0 0)
  (vector-ref v 2)                   → 0
  (vector-set! v 2 100)
  v                                  → #(0 0 100 0 0)
  (vector-ref v 2)                   → 100
#+end_src

Что будет?

#+begin_src scheme
  (define m (make-vector 4 (make-vector 4)))
#+end_src

На первый взгляд, мы создаём квадратную матрицу. На самом деле, мы
создаём два вектора, все элементы одного вектора содержат =0=, все
элементы второго --- ссылку на первый.

#+begin_src scheme
  m              → #(#(0 0 0 0) #(0 0 0 0) #(0 0 0 0) #(0 0 0 0))
  (vector-set! (vector-ref m 0) 0 1)
  m              → #(#(1 0 0 0) #(1 0 0 0) #(1 0 0 0) #(1 0 0 0))
#+end_src

Вектор можно преобразовать в список и наоборот

#+begin_src scheme
  (vector->list #(a b c))            → (a b c)
  (list->vector '(a b c))            → #(a b c)
#+end_src

*** Строки
   :PROPERTIES:
   :CUSTOM_ID: строки
   :END:
Тип данных =string= хранит в себе последовательность литер (characters).
Литерал для строки --- текст, записанный внутри двойных кавычек:
="Hello!"=.

Внутри строк допустимы стандартные escape-последовательности языка Си:

#+begin_src scheme
  "one line\ntwo lines"              ; строка со знаком перевода строки
  "I say: \"Hello!\""                ; заэкранированная кавычка
#+end_src

Операции над строками:

#+begin_src scheme
  (make-string 10 #\a)               → "aaaaaaaaaa"
  (string-ref "abcdef" 3)            → #\d               ; счёт тоже с 0
  (string->list "abcdef")            → (#\a #\b #\c #\d #\e #\f)
  (list->string '(#\H #\e #\l #\l #\o)) → "Hello"
  (string? "hello")                  → #t
  (string? 'hello)                   → #f
  (string-append "штука" "турка")    → "штукатурка"
#+end_src

Литеры задаются так:

#+begin_src scheme
  #\x            ; буква «икс»
  #\7            ; цифра «семь»
  #\(            ; литера «круглая скобка»
  #\space        ; пробел
  #\newline      ; \n в Си
  #\return       ; \r в Си
  #\tab          ; \t в Си
  #\             ; хотели пробел, но получили ошибку синтаксиса#+end_src

В ДЗ потребуется функция =(whitespace? char)=, возвращающая истину, если
литера --- пробельная (пробел, табуляция, новая строка, возврат
каретки).

#+begin_src scheme
  (whitespace? #\space)              → #t
  (whitespace? #\z)                  → #f
  (whitespace? (string-ref "a b" 1)) → #t
#+end_src

Выбор подстрок =(substring …)= изучить самостоятельно.

** Императивное программирование на языке Scheme
  :PROPERTIES:
  :CUSTOM_ID: императивное-программирование-на-языке-scheme
  :END:
До этого мы рассматривали декларативное программирование, в котором
у нас не было:

- присваиваний,
- циклов,
- процедур с побочными эффектами,
- недетерминированных процедур --- процедур, результат которых
  определяется не только значениями аргументов.

В Scheme есть средства не только декларативного программирования,
но и императивного. Т.е. можно и присваивать переменным новые значения,
и пользоваться процедурами, которые вызываются не только ради
возвращаемого значения, но и дополнительных действий (побочного
эффекта).

В Scheme не определён порядок вычисления аргументов в вызове процедуры.
Но в императивном программировании порядок вычисления (а вернее,
выполнения) операций существенен. Поэтому в первую очередь нам нужно
средство упорядочивания выполнения операций.

*** 1. =begin=
   :PROPERTIES:
   :CUSTOM_ID: begin
   :END:
Если мы имеем вызов вида

#+begin_src scheme
  (f (g …))
#+end_src

то в Scheme гарантируется, что сначала вычислится =(g …)=, а потом
=(f …)=. (В Haskell не гарантируется.)

Но если мы имеем вызов вида

#+begin_src scheme
  (f (g …) (h …))
#+end_src

то, что выполнится раньше --- =g= или =h= --- зависит от реализации.
Разные реализации Scheme могут вычислять аргументы справа налево или
слева направо.

Но если нужно вывести на печать несколько значений, то порядок вызова
будет существенен: функции должны вызваться в правильном порядке. Можно
извратиться, например, конструкцией =let*=:

#+begin_src scheme
  (let* ((x (display "Hello, "))
         (y (display "World!")))
    #f)
#+end_src

Но это избыточно, т.к. в Scheme уже есть особая форма =(begin …)=,
гарантирующая порядок вычисления:

#+begin_src scheme
  (begin
    (display "Hello, ")
    (display "World!"))
#+end_src

(На самом деле =begin= может быть библиотечным макросом, который неявно
трансформируется в тот же =let*=).

=begin= выполняет действия в том порядке, в котором они записаны.

Результатом =begin='а является результат последнего действия.

#+begin_src scheme
  (begin (* 7 3) (+ 6 4))            → 10
#+end_src

Результат умножения будет отброшен, умножение тут вообще бессмысленно.

**** Неявный =begin=
    :PROPERTIES:
    :CUSTOM_ID: неявный-begin
    :END:
Некоторые конструкции Scheme позволяют записывать несколько действий
подряд, например =lambda=, =define=, определяющий процедуру, =cond=,
=let=, =let*=, =letrec=.

#+begin_src scheme
  ; синтаксический сахар             ; эквивалентен
  (lambda (x y)                      (lambda (x y)
    (display x)                         (begin
    (display y))                           (display x)
                                           (display y)))

  (define (f x y)                    (define (f x y)
    (display x)                         (begin
    (display y)                            (display x)
    (+ x y))                               (display y)
                                           (+ x y)))

  (let ((x 100)                      (let ((x 100)
        (y 200))                           (y 200))
    (display x)                        (begin
    (display y)                          (display x)
    (* x y))                             (display y)
                                         (* x y)))

  (cond ((> x y)  (display x) (- x y))
        …)

  (cond ((> x y)  (begin (display x) (- x y)))
       …)
#+end_src

*** 2. Присваивания, =set!=
   :PROPERTIES:
   :CUSTOM_ID: присваивания-set
   :END:
Синтаксис:

#+begin_src scheme
   (set! ‹имя переменной› ‹выражение›)
#+end_src

Переменной может быть как имя, объявленное при помощи =define=, так
и параметр процедуры или имя, определённое =let=, =let*=, =letrec=.

Например

#+begin_src scheme
   (define counter 0)
   counter                           → 0
   (set! counter 100)
   counter                           → 100
   (set! counter 0)

   (define (next)
     (set! counter (+ counter 1))
     counter)

   (next)                            → 1
   (next)                            → 2
   (next)                            → 3
   counter                           → 3
   (set! counter 7)
   (next)                            → 8
#+end_src

**** Статические переменные в Scheme
    :PROPERTIES:
    :CUSTOM_ID: статические-переменные-в-scheme
    :END:
В языке Си есть понятие *статическая переменная* --- глобальная
переменная, видимость которой ограничена одной функцией. Объявляется она
с использованием ключевого слова =static=:

#+begin_src scheme
  void f() {
    int x = 0;
    static int y = 0;

    x = x + 1;
    y = y + 1;

    printf("x = %d\n", x);
    printf("y = %d\n", y);
  }

  int main(int argc, char **argv) {
    f();
    f();
    f();

    return 0;
  }
#+end_src

Напечатается:

#+begin_src scheme
  x = 1
  y = 1
  x = 1
  y = 2
  x = 1
  y = 3
#+end_src

Значение статической переменной сохраняется между вызовами функции
(сравните выше поведение =x= и =y=).

В языке Scheme статических переменных нет, но есть идиома (приём
программирования), позволяющая их имитировать: т.е. создавать
переменные, видимые только внутри функции, но при этом сохраняющие
значение между вызовами.

Вспомним, что конструкция

#+begin_src scheme
  (define (f x y)
    ‹тело процедуры›)
#+end_src

есть синтаксический сахар для

#+begin_src scheme
  (define f
    (lambda (x y)
      ‹тело процедуры›))
#+end_src

Что будет, если мы эту лямбду обернём в let-конструкцию?

#+begin_src scheme
  (define f
    (let (‹объявления каких-то переменных›)
      (lambda (x y)
        ‹тело процедуры›)))
#+end_src

Let-конструкция свяжет с переменными значения и вернёт лямбду как свой
результат. Переменная =f= будет связана с лямбдой. Что же будет
с переменными?

Эти переменные будут видимы внутри лямбды, не будут видимы вне
конструкции let, их значения будут сохраняться между вызовами.

Эти переменные будут вести себя как статические переменные в Си.

Перепишем пример с =(next)=, чтобы переменная =counter= была
статической.

#+begin_src scheme
  (define next
    (let ((counter 0))
      (lambda ()
        (set! counter (+ counter 1))
        counter)))

  (next)                             → 1
  (next)                             → 2
  (next)                             → 3
#+end_src

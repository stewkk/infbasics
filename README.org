#+TITLE: Informatics basics
#+AUTHOR: Starovoytov Alexandr, Grechko Georgy
#+DATE: <2021-09-04 Sat 13:50>
#+SETUPFILE: retro_dark.theme

[[https://github.com/stewkk/iu9-scheme/][Лабы и дз]]

* Преподаватель
  - Коновалов Александр Владимирович
  - 89175404352
  - akonovalov@bmstu.ru
  - a.v.konovalov87@mail.ru
* Основные понятия информатики
** Данные
это представление фактов, понятий, инструкций в форме, приемлемой
для обмена, интерпретации или обработки человеком или с помощью
автоматических средств
** Алгоритм
это конечная совокупность точно заданных правил решения прозвольного класса
задач или набор инструкций, описывающий порядок действий исполнителя для
решения некотрой задачи
** Свойства алгоритма:
1. Дискретность \\
    делится на отдельные элементарные части,
    отвечающие за определенные действия.
2. Детерминированность \\
    на одних и тех же входных данных - один и тот же результат.
3. Понятность \\
    элементы алгоритма должны быть понятны исполнителю.
4. Завершаемость \\
    если не завершается - то это вычислительный процесс.
5. Массовость \\
    алгоритм пригоден для решения всех задач данного типа.
6. Результативность \\
    указывает на наличие таких исходных данных, для которых реализуемый
    по заданному алгоритму вычислительный процесс должен через конечное
    число шагов остановиться и выдать искомый результат.
** Компьютерная программа
это алгоритм, записанный на некотором языке программирования
** Язык программирования
формальный язык, предназначенный для записи компьютерных программ
** Компьютер
программно управляемое устройство для обработки информации
** Подпрограмма
некоторый именованный блок кода. \\
Вызывающая программа приостанавливается, управление передается
подпрограмме,
по завершению управление передается обратно
** Сопрограмма
в отличие от подпрограммы работает поочередно с вызывающей программой.
При повторном вызове возобновит выполнение с момента, где остановилась
* Парадигмы программирования
совокупность идей и понятий, определяющих стиль написания компьютерных
программ (подход к программированию). Это способ концептуализации,
определяющий организацию вычислений и структурирование работы, выполняемой
компьютером.
** Основные группы парадигм
1. Императивные \\
   способ записи программ, в котором указывается последовательность
   действий \\
   основной признак - оператор присваивания (меняющий значение переменной)
   1. Структурное программирование \\
      программа является композицией блоков с одним входом и
      одним выходом \\
      (есть операторы ветвления и цикла, но нет goto)
   2. Процедурное программирование \\
      совокупность подпрограмм, где одни подпрограммы вызывают другие
   3. Объектно-ориентированное \\
      программа рассматривается как набор некоторых взаимодействующих
      объектов. \\
      Объект сочетает в себе данные и методы их обработки,
      методы вызываются в ответ на сообщение: \\
      посылаем сообщение объекту -> вызывает метод -> возвращает ответ \\
      объекты объединяются в классы
2. Декларативные \\
   способ записи программ, в котором описывается взаимосвязь между
   данными, описывается цель, но не последовательность шагов ее вычисления
   1. Функциональное \\
      алгоритм записывается как набор взаимосвязанных функций, функции
      рассматриваются с математической точки зрения, \\
      описывает взаимосвязь между данными и результатом
      #+begin_src "c"
      x = f(y) + g(z);
      #+end_src
   2. Логическое (Prolog + отчасти SQL) \\
      алгоритм описывает взаимосвязь между понятиями. \\
      Выполнение программы сводится к выполнению запросов
3. Метапрограммирование \\
   метаирония. Программа рассматривается как данные/объект для
   другой программы
   1. Программу пишут программы \\
      Например: макросы, генераторы кода, шаблоны С++ (фигня нечитаемая
      зачем он постоянно в руках часы крутит попит симпл димпл круче
      нет попит симпл димпл попит симпл димпл маленький красивый
      попит большой и милый)
   2. Программа взаимодействует с вычислительной средой \\
      Рефлексия или интроспекция - самоанализ. \\
      Например, посмотреть поля и значения в объекте класса
** примеры
#+begin_example
ИП: sort(array);
ФП: sorted_list = sort(list)
    sorted_list - константа, т.к. нет присваивания
ЛП: sort(unsorted, sorted)
#+end_example
* Язык Scheme
** информация о языке
Lisp 1950-е годы Джон МакКарти \\
LISt Processing \\
Scheme 1970-е годы Абельсон и Сассман \\
изучаем R5RS \\
современная редакция R7RS
- другие языки семейства LISP:
    - Common Lisp
    - Clojure
    - Racket
** основные постулаты языка LISP
1. единство кода и данных
2. все есть список
3. выражение является списком \\
   операция указывается в первом элементе
4. все выражения вычисляют значения (почти все)
** операторы
#+begin_src scheme :session :results value
;; <терм> ::= <атом>|<список>
;; <атом> ::= <перем>|<число>|<симол>|<строка>
;; <список> ::= (<термы>)
;; <термы> ::= <пусто> | <терм><термы>
;; <пусто> ::=
;; i-am-variable - имя переменной может включать "-", "+", "*", "/"...
(+ 1 2 3) ;; список
;; "+" - имя функции сложения
;; "1 2 3" - аргументы
;; элементы списка разделяются пробелами

#+end_src

#+RESULTS:
: 6

#+begin_src scheme :session :exports both
((a 1)(b 2)(c 3)) ;; список списков

;; по умолчанию выражение вида
;; (f a b c) - вызов функции
;; ((f x) y) - сначала вызывается (f x),
;; то, что она вычислит с аргументом y
;; Особая форма - первый элемент списка - ключевое слово

(define pi 3.1415926)
;; pi - имя переменной
;; 3.14.. - значение

(define pi (* 4 (atan 1)))

(define (f a b c) ;; опеределяет функции
    (+ (* 2 a) (/ b c)))

;; (if <выраж 1>
;;     <выраж 2>
;;     <выраж 3>)

;; Если <выраж 1> - ложь,
;; значением (if ...) станет значение <выраж3>
;; (<выраж 2> не вычисляется), и наоборот

;; #f - ложь
;; #t - истина
;; if считает истиной все что не ложь
#+end_src


#+begin_src scheme :session :exports both
(if 1 2 3)
#+end_src

#+RESULTS:
: 2

#+begin_src scheme :session :exports both
(if #f (/ 1 0) (/ 10 5))

#+end_src

#+RESULTS:
: 2

#+begin_src scheme :exports both
(if #t (/ 1 0) (/ 10 5))
#+end_src

#+RESULTS:
: Throw to key `numerical-overflow' with args `("/" "Numerical overflow" #f #f)'.

#+begin_src scheme
;; (< x y)
;; (> x y)
;; (= x y)
;; >=
;; <=
;; (/ x y)
(/ 10 3)
#+end_src

#+RESULTS:
: 10/3

#+begin_src scheme :session :exports both
;; (quotient x y) - целое деление
(quotient 30 7)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme :session :exports both
;; (remainder x y) -> остаток
(remainder 30 7)
#+end_src

#+RESULTS:
: 2

#+begin_src scheme :session :exports both
;; "особые формы"
;; (and e1 e2 ... en) - возвращает #f если хотя бы один ei = #f, иначе en
;; (or ...) - вернет первое не ложное значение


(and 1 2 #f (/ 1 0))
#+end_src

#+RESULTS:
: #f
#+begin_src scheme :session :exports both
;; (or (= x 0) (/ 1 x)) - не приведет к ошибке деления на 0, никогда
#+end_src

#+begin_src scheme :session :exports both
(or (= 1 0) (/ 1 0))
#+end_src

#+RESULTS:

#+begin_src scheme :session :exports both
;; (not x) - логическое отрицание #f -> #t
;; not x -> #f, x != #f
;; вычисления ленивые!
#+end_src

#+begin_src scheme
(+ 1 2 3)
#+end_src

#+RESULTS:
: 6

#+begin_src scheme :session :exports both
(define pi (* 4 (atan 1)))
#+end_src
#+begin_src scheme :session :exports both
(define (area r) (* r r))
#+end_src
#+begin_src scheme :session :exports both
(define e (exp 1))
#+end_src
#+begin_src scheme :session :exports both
(define (hypot x y) (sqrt (+ (* x x) (* y y))))
; if всегда в 3 строки
#+end_src
#+begin_src scheme :session :exports both
(define (fac x) (if (= x 0)
                     1 (* (fac (- x 1)) x)))
#+end_src
#+begin_src scheme :session :exports both
(define (my-positive? n) (> n 0))
#+end_src
#+begin_src scheme :session :exports both
(define (my-abs x)
  (if (< x 0)
      (-x)
      x))

#+end_src
#+begin_src scheme :session :exports both
(define (factorial n)
  (define loop acc i)
  (if (> i n)
      acc
      (loop (* acc i) (+ i 1)))
  (loop 1 1))
#+end_src
#+begin_src scheme :session :exports both
(define (my-odd n)
  (= 0 (remainder n 2)))
#+end_src

#+RESULTS:
: #<unspecified>

#+begin_src scheme :session :exports both
(define (my-even n)
  (= 1 (remainder n 2)))
#+end_src

#+RESULTS:
: #<unspecified>

#+begin_src scheme :session :exports both
(my-odd 1)
#+end_src

#+RESULTS:
: #f

#+begin_src scheme :session :exports both
(my-odd 2)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(my-even 1)
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :session :exports both
(my-even 2)
#+end_src

#+RESULTS:
: #f

* Лекция 2
** Codestyle in if-statements
1. Условное выражение лучше писать в 3 строки: \\
   условие \\
   ветка 1 \\
   ветка 2
2. Плохой стиль - использовать в ветках #t и #f
   #+begin_src scheme
;; неверно
(if e1
    e2
    #t)
;; верно
(or (not e1) e2)

;; неверно
(if e1
    #t
    e2)
;; верно
(or e1 e2)

;; неверно
(if e1
    e2
    #f)
;; верно
(and e1 e2)

;; неверно
(if e1
    #f
    e2)
;; верно
(and (not e1) e2)
   #+end_src
** Выражение cond
#+begin_src scheme
(cond (c1 e1)
      (c2 e2)
      ...
      (cn en)
      (else eE)) ;; можно без else
;; для первого же условия ci не являющ #f выполняет ei, иначе eE
;; допустимо писать #f #t
#+end_src
** Выражение case
не будет на экзамене,
*** TODO добавить самостоятельно
** Простые (не составные) значения
+ Числа: 5, 100500, 6.12324, -1 1/3...
+ строки: "Hello", можно использовать esape-последовательности языка C
+ Логический тип: #t #f
+ Литерный (character): #\x, #\newline
+ Символьный (symbol): 'hello
+ Процедурный (lambda (...))
+ ...
** Функции высших порядков
#+begin_src scheme
;; Конструкция (lambda ...) строит процедуру
;; принятно "процедура", а не "функция"
(lambda (<параметры>)
  <выражение>)
;; В результате получается значение, которое можно вызвать
;; Например:
((lambda (x y)
   (+ x y))
 5 3) ;; -> 8
(lambda (x y) ;; ->
  (+ x y)) ;;    -> СТРОИТ ПРОЦЕДУРУ
;; эта процедура вызывается с 2-мя параметрами: 5 3

((lambda (f) (f (f 2))) ;; принимает функцию вызывает ее с 2, вызывает ее от результата первого вызова
 (lambda (x) (* x x))) ;; -> 16
;; (2^2)^2 = 16

((lambda (f) (f (f 81))) sqrt) ;; -> 3

((lambda (f) (f (f 81)))
 lambda (y) (sqrt y)) ;; -> 3

;; (lambda (x) (g x)) тожд. g - хватает для описания любого алгоритма

;; (lambda (x y) (n x y)) тожд. n
;; n - конверсия буква "эта"

(define pi (* 4 (atan 1)))

(define square
  (lambda (x) (* x x)))
;; то же, что и:
(define (square x) ;; -> Сокращенная запись
  (* x x))         ;; -> (синтаксический сахар)

;; компилируется в один и тот же код

(define (f ...) ...)
;;   ||
(define f (lambda (...) ...))

(define (multi-apply f x n)
  (if (= n 0)
      x
      (f (multi-apply f x (- n 1)))))
f'(x) = x
f'(x) = f(f(f...f(x)...))
;;      n раз
(define (square x)
  (* x x))
(multi-apply square 3 3) ;; -> 6561 = 3^8
(multi-apply square 2 4) ;; -> 65536 = 2^16
(multi-apply
 (lambda (z) (+ 1 z))
 0 7) ;; -> 7

(define (select n)
  (cond((= n 0) +)
       ((= n 1) -)
       ((= n 2) (lambda (x y)
                  (sqrt (+ (* x x) (* y y)))))
       (else (lambda (x y) 0))))

((select 0) 2 3) ;; -> 5
((select 1) 10 7) ;; -> 3
((select 2) 3 4) ;; -> 5
((select 10) 100 500) ;; -> 0
#+end_src
* Лекция 3
+ 1 порядок - простое возвр значение (не функция)
+ высшего порядка - возвращает функцию
+ в Scheme - функции - объекты 1го класса
+ объекты первого класса - с которыми можно применять все допустимые операции (не пораженные в правах)
 #+begin_src scheme
(cond (усл1 выр1)
      (услk -> проц)
      ...
      (else выражE))

;; пример:
(define (f a b c)
  (cond (a -> (lambda (x) -> (* x x)))
        (b -> sqrt) ;; ((assoc xsk) -> car)
        (c -> -)
        (else 0)))
(f #f 9 5) ;; -> 3
(f 15 3 #f) ;; -> 225
(f #f #f 100) ;; -> -100
(f #f #f #f) ;; -> 0


(define mul
  (lambda (x)
    (lambda (y) (* x y))))

((mul 7) 9) ;; -> 63
((mul 3) 3) ;; -> 9
(define twice (mul 2)) ;; дважды
(define triple (mul 3)) ;; трижды
(twice 7) ;; -> 14
(triple 12) ;; -> 36

(define (pair x y)
  (lambda (f) (f x y)))

(define (first p)
  (p (lambda (x y) x)))

(define (second p)
  (p (lambda (x y) y)))

(define p1 (pair 2 3))
;; p1 ~ (lambda (f) (f 2 3))
(first p1) -> (first (lambda (f) (f 2 3))) ->
-> ((lambda (f) (f 2 3))
    (lambda (x y) x)) ->
-> ((lambda (x y) x) 2 3) -> 2
(first p1) ;; -> 2
(second p1) ;; -> 3

(define (swap p)
  (p (lambda (x y) (pair y x))))
(define (swap p)
  (pair (second p) (first p)))
 #+end_src
** let, let* и letrec
Используются для определения вспомогательных переменных
#+begin_src scheme
(let ((перем1 знач1)
      (перем2 знач2)
      ...
      (перемn значn))
  выраж)
;; переменные могут использоваться только в выражении "выраж"

;; вычисление площади треугольника по формуле герона:
(let (s a b c)
  (let ((p (/ (+ a b c) 2)))
    (sqrt (* p (- p a) (- p b) (- p c)))))
;; Значение "вспомогательной" переменной не может
;; ссылаться на предыдущие
(let ((v1 e1) .. (vN eN)) e)
;;       |||
((lambda (v1 .... vN) e)
 e1 ....... eN)
;; порядок вычисления аргументов не определен
;;;;;;;;;;;;;;;;;;;;
;; let*
(let* ((перем1 знач1)
       (перем2 знач2)
       ...
       (перемn значn))
  выраж)
;; В выражении значk можно использовать перемi, i < k
(let* ((a 7)
       (b (+ a 5))
       (c (* a b))
       (d (- a c)))
  (+ a b c d))
;; значения вычисляются строго сверху-вниз
(let* ((v1 e1) ... (vN eN)) e)
;;          |||
(let ((v1 e1))
  (let ((v2 e2))
    (let ((v3 e3)))
    .........
 e))


            ;;;;;;;;;;;;;;;;;;
(letrec ((перем знач)
         (перем знач)
         ....
         (перемn значn))
  выраж)
;; в выражении значk можно использовать любые переменные

(define (fact n)
  (letrec ((loop
            (lambda (i res)
              (if (> i n)
                  res
                  (loop (+ 1 i) (* i res))))))

  (loop 1 1)))
;; let с рекурсией
;; аналогичен обычному let, но в перем0 кладется рекурсивная процедура
(let перем0 ((перем1 знач1)
             (перем2 знач2)
             ......
             (перемn значn))
     выраж)
;; рекурсивная функция - с n параметрами
(define ((перем0 перем1 .. перемn)
         выраж)
  (перем0 знач1 ... значn))
(define (fact n)
  (let loop((i 1) (res 1))
    (if (> i n)
        res
        (loop (+ i 1) (* res i)))))

(define (loop i res)
  ......)
(loop 1 1)
#+end_src
